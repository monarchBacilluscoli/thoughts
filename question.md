# 自行总结的问题

## 1.
2. 程序集，托管模块，清单，元数据的关系（要落实，程序集是一个或多个类型定义文件和资源文件的集合，清单是程序集的整体元数据，包含了程序集的整体描述和包含的文件信息，）
3. 执行程序集代码时的程序集调用案例(程序集类型的加载，JITCompailier入口，对方法进行编译，)。
1. /optimize和/debug的效果（前者-生成nop和条件跳转到下一句，后者生成PDB允许源代码和IL以及IL和本地代码的的映射，允许attach调试）
4. 验证IL是指什么，在什么时候发生（验证是编译成本机指令时，由CLR执行，保证方法被正确调用（参数数量、类型、返回值正确使用、方法都有返回语句）（15））
5. 安全的代码和不安全的代码，为什么不安全？（直接操作内存，无法验证）
6. 

## 2. 生成、打包、部署和管理应用程序及其类型
1. 什么是清单，多文件和单文件程序集有何不同
2. 模块和程序集有何不同。（程序集不包含清单元数据表，但对于ref的类型和方法还是有包含）
3. 为什么没有清单的程序集不能被Windows执行
4. 运行时什么时候会加载用到的程序集，编译时呢？(运行时是到函数要JITCompalier的时候，编译时是一开始就要（但是只用元数据就可以很ok，66，GAC才需要IL代码，编译时只需要元数据就行）44)

## 3. 共享程序集和强命名程序集
5. 强命名程序集的签名过程和验签过程。
6. 安装到GAC的目的
7. GAC中的程序集验签和私有部署的程序集验签有什么不同（私有部署每次加载都要做）
8. 何时进行类型解析（JIT编译时（JIT编译指的是之前章节说过的哪一部分？）），类型解析如何运作（从MethodRef到TypeRef最后到AssemblyRef）
9. 对付同一程序集（相同/不同文件），不同程序集的解析，如何搞定。

## 4. 类型基础
1. Object都定义了啥（GetType最基本的，toString调试要用，equals也很基本，GetHashcode就比较奇怪）
2. Object成员的保护成员都是啥（MemberwiseClone，Finalize）
3. new的时的的的的时候发生了什么 （计算所需内存，分配内存并zero化，初始化负载，初始化成员）
4. 类型转换规则（向派生转换，向基类转换）
5. is和as操作符
6. GetType可以被new，调用真正GetType的时候是callvirt Object的，而调用new的...你懂的。
7. using用来给类型（或命名空间）别名。
8. 调用静态方法、实例方法和虚方法的区别
9. 栈的构建方向（高地址到低地址，90）
10. 再一次确证，CLR将IL转换成本机指令时需要加载所有的类型：加载程序集和数据表示（但是这些类型其中的方法还是不一定会被编译） 
11. 调用非虚实例方法的调用会向基类回溯。（并没有说是call还是callvirt，95）
12. 调用虚方法CLR会做一些事情，从调用变量到调用对象，查看对象的type，然后从type的方法表中调用。
13. 调用静态方法则直接找类型变量的方法表。
14. 类型对象的类型对象指针指向哪里呢？（他自己）

## 5. 基元类型、引用类型和值类型
1. 基元类型的float对应的FCL类型是什么
2. dynamic类型被CLR视作什么
3. 基元类型能否转型，转型的规范是什么（能，安全的，即不发生精度损失的）
4. 检测算数溢出的几种方法（/checked+，使用checked/unchecked操作符和块，
5. 为什么引用类型成本比较高。
6. 值类型的继承体系的特点（继承自ValueType，但不允许从别的类型中继承（？原来CLR默认就是多继承了），并且值类型隐式密封，不允许被继承）如果它不是隐式密封，那就要涉及到各种继承操作，虚函数啊啥的，就要...
7. 值类型也有类型实例吗？否则它的函数入口搁哪里呢？
8. 使用new和不使用new创建值类型的差别在哪里
9. 对对象进行装箱和拆箱的过程
10. 拆箱只能转换为之前装箱的类型（对么，毕竟在栈上操作的就是那个对象）
11. 如何更改堆上的已装箱类型的字段值（先拆箱，更改字段，再装箱）
12. “如何更改已装箱的值类型的字段”，看起来是个简单的问题，“给值类型安排一个修改它的值的方法不就行了？”，NO，值类型装箱之后如果想调用这个方法，那肯定不能用装箱的那个类型调用（因为它不知道这个方法）。如果转型成这个值类型再调用，那实际上是经过了拆箱复制，并且修改的是栈上的对象。所以怎么“本地修改”就是个问题了，于是才产生了“使用接口来实现”的方式。
13. 使用接口来实现已装箱值类型的修改会出现什么问题？（如果你整个程序运行巨细靡遗的你都清楚，那么没问题，但是如123所示，对未装箱值类型对象转型到接口类型和对已装箱值类型对象转型到接口类型的行为是不一致的，这种问题如果你都心知肚明，并且何时装箱拆箱你也清楚的话那可以尝试这样。但是一旦自己并不清楚，并且某些产生了装箱拆箱的代码不在你自己的掌控之中时，那这个行为就近似于“未定义的”，问题就大了。）
14. 作者为什么推荐值类型采用全部readonly的修饰？（123）
15. Object.Equals的实现逻辑是什么。
16. 测试同一性的时候到底是==、Equals还是别的什么可靠？（`Object.ReferenceEquals`，因为这俩都有可能被重载，静态函数不会）
17. Equals方法的正确实现逻辑？（value是否null->是否指向同一对象->是否同类型对象->是否所有当前继承层次字段相等->是否基类Equals（所以需要调用基类Equals方法），124）。
18. 为什么重写Equals同时要重写GetHashcode（因为在Dictionary之中只有Hashcode）
19. 哈希算法使用的字段最好不可变，为什么。
20. dynamic允许向派生方向隐式转型，和一般情况不同。但即使如此也需要对dynamic的实际对象进行check。
21. var和dynamic的区别（var在IL编译时确定（根据表达式），dynamic在实际运行的时候确定）

## 8. 方法
1. param的使用方式

## 11. 委托
1. 委托是immutable
2. 这一章出现了两个使用同步操作的结构：
	1. volatile.Read事件字段到temp并执行temp
	2. 保存修改之前的状态，然后构建新状态，使用Interlocked.CompareExchange()对状态没有修改进行确认并修改。如果前一步没有修改成功则while继续修改。
	这两个结构确有一些不同，使用的工具也不一致。只读就copy过来就好，覆盖需要check状态没有第三方改变。(如果用c++做会是什么样？)
3. 显式实现事件的逻辑是
	1. 用于处理这样一种问题：
		一个UI组件可能需要进行N多种类型的回调，如果每个回调都创建一个event对象，编译器生成的代码和CLR实际创建的字段就占用太多内存了，毕竟UI组件还那么多。
		那么我们能不能用一个简单的标识符把add、remove整合在一起，并用一个Dic来统一管理呢？
		答案当然是可行的。
	2. 有几个点需要注意:
		1. 字典的value是delegate，也就是可以引用所有的方法指针。
## 14. 字符、字符串和文本处理
1. string类型是引用类型还是值类型
2. 什么是字符串留用。
3. 什么是字符串池，和字符串留用的区别是什么。
4. StringBuilder的基本方法和属性。
5. 字符是存储为ASCII吗？
6. Parse由String提供还是由谁提供？
7. 如何对字符串进行编码传输。（`System.Text.Encoding`）
8. 处理字符串数分块传送的无状态问题。（encoding的Encoder和Decoder）
9. SecureString的使用（Marshal的引入，写入和清空方法的配对。）

## 12. 泛型
1. 泛型的类型参数支持不支持ref out等修饰符？
	1. 不支持，这个修饰符是在定义泛型类型的时候设定的，360
	2. 因为这根本就是两个东西，T是类型，能用在返回值、字段等位置，ref和out是行为修饰，并且只能用在参数，你说你写一个T=ref Object放在返回值和字段里是啥意思？

## 13. 接口
1. 接口方法的定义和实现的访问修饰似乎有差异，导向了什么？
2. 什么是显式接口方法实现，有什么特点（只有明确该接口类型的变量才能调用）。有什么作用？

## 14. 方法
1. override和new的区别是什么。（重写和覆盖，new打断了虚函数的调用链，目的是为了处理继承的不能够更改的类）
https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords
这个案例描述了一种情况，本来别人的基类有DrawPoint和DrawLine，你继承之并写了DrawRactangle，但是后来那个公司重写了基类加上了DrawRactangle，你拿这个版本编译就需要二选一，要么override还用你自己的代替之，要么就全部重写你的函数名，要么就用New来去掉警告。（感觉没啥用啊）
2. call 和 callvirt的区别？
看thoughts，几点：
	1. call调用由后面token直接定义的那个方法，而不会去管obj的实际类型（晚绑定）。callvirt调用token会考虑到实际类型。
	2. callvirt会检查调用者（c#）代码是否为null，call不会（哪个层次的检查？c#还是il）
	3. 根据2，callvirt不能调用静态方法，因为没有obj给你check是否为null。
	另外有说“call用于以非虚形式调用虚方法”，它的使用情境是子类的虚函数中调用Base的同名虚函数，如果还用callvirt，那就无限循环了。
3. 为什么值类型一般用call
	1. 因为值类型都是非null
	2. 值类型是sealed，无需虚调用。
	3. 同时，因为callvirt需要调用虚方法，所以需要check类型对象，故需要装箱。

	

## 17. 委托
1. lambda表达式可以实现闭包的原理是什么？（其实和C++一样，https://blog.csdn.net/cjolj/article/details/60868305)
2. 实名委托可以实现闭包吗？
3. Action和一般Lambda函数差异如何？
4. Lambda表达式捕获外部对象默认是按什么捕获？（按照CLR的尿性，肯定是按引用啊）
5. 委托算是类型还是算是实例
6. 委托生成的类型的结构如何？
	1. 方法（使用者需要知道的）：构造器，Invoke，两个异步回调方法：BeginInvoke和EndInvoke
	2. 字段（委托的原理）：指向实例的引用，指向方法的IntPtr，委托链数组
7. 它继承的MulticastDelegate结构如何？有什么强大的方法？
7. 委托可以在全局范围中定义吗？为什么？(可以，因为是类)
8. 委托链中存储的是什么类型的变量？考虑只能是什么类型的变量才能实现对instance方法的调用？
9. 委托链Remove实例方法的机制是什么？对什么进行匹配(实例引用和方法指针)？一次对所有匹配的全部删除还是？
10. 含有返回值的委托链如何返回值？
11. .net定义了泛型委托Func和Action，差别是什么？(?ref和out这类修饰符在泛型的时候怎么处理？哦，如果使用ref就要自己定义自己的，所以看来泛型不支持ref？360)
12. lambda表达式是实例方法还是静态方法？对方法本身和对delegate而言？（其实就lambda表达方式的构建方式而言是实例方法（经过确认，没有也是instance修饰，但是为啥？没必要啊），但是就lambda表达式定义的那一句中看，只要是有引用实例字段，那对Delegate而言就是实例方法）
13. lambda表达式赋值给delegate可以省略什么？
	1. 参数类型（delegate声明了参数类型）
	2. 大括号（只有一句用不着）
	3. 参数括号（只有一个参数用不着）

14. delegate可以定义到method内吗？不可以，因为delegate实际上是类型定义，没见过那个类定义到函数里的
。它应该定义在哪里？一般是和自己定义的类齐平，当然定义到类里面做嵌套也是很可以的，但注意它属于类型成员了
15. GetInvocationList的用法。及其需要解决的问题？(直接返回委托链数组，解决Invoke某个函数调用阻塞或不能返回全部返回值的问题。（听起来action可以用Invoke，Func最好用GetInvocationList）)
16. 委托好像不能绑定属性，因为不知道方法名16. 委托好像不能绑定属性，因为不知道方法名
17. 委托与反射基本没看

## 20. 异常处理
1. try...catch...finally的执行顺序（在同一层次以及多个函数调用层级上）是怎样的（try块如果出现了异常将高层catch块逐步匹配，匹配成功之后先从下到上执行finally然后执行匹配的catch最后catch那一层的finally（如果按照高层不管底层的视角，其实这个很好理解））
说起来如果有底层的逻辑保驾护航似乎自己也不用写很多异常处理逻辑。
2. 任何情况finally块都会工作？那么卸载AppDomain的时候嘞？（`ThreadAbortException`会使得所有finally块工作, 404注释）
	1. Environment.FailFast()（卸载进程）方法调用不会执行finally块，因为使用这个方法的时候默认状态已经差到不能再运行什么破代码了。
3. Exception包含了点什么东西，
	1. StackTrace里面包含了什么？
4. 定义自己的异常类这一部分的代码需要好好看看。
5. Loader堆和GC堆是什么？有什么用？
6. 约束执行区域和代码协定是什么？
7. using在语句块结束之后会做什么？ 
8. 提到了”严密监视状态“，应该指的是类似“在写入文件之前要记录文件流开始的position以便在磁盘满的时候回滚状态”的记录初始状态的操作。
9. 隐藏实现细节来维系协定一节描述了一种“内部捕获实际异常类型（跟实现有关）并向外抛出一个调用者视角下可以理解的异常类型”的范式，向调用者隐藏了具体的实现并避免了迷惑。但另外还有关键的一点是，原来的异常要作为新的异常的InnerException。
10. 如果调试中出现“unhandled exception”，它除了会弹窗之外还会在Local variables里出现。

## 21. 托管堆和垃圾回收
1. Dispose和Finalize的差别是什么
	1. Dispose可以主动被调用，Finalize是由GC调用，448）
	2. Dispose调用是释放本机资源，并非对对象进行Finalize，也就是说对象还在。
2. 托管堆的NextObjPtr是什么（下一个对象在堆中分配的位置），它的操作的基本模式是什么（下一题）
3. C# new操作符会进行怎样的操作（计算所需空间+负载大小->如果有空间，开辟空间至NextObjPtr位置->zero化->调用构造器->NextObjPtr加上size->返回对象引用）
4. CLR进行GC的过程（挂起所有线程->设定所有对象的同步索引块->遍历根标记可达对象->压缩回收+更改根所指向的位置）
5. 静态字段引用的对象生存期如何（从类型被初始化到AppDomain卸载）
6. 代的运行机制？
	1. 什么时候GC开始？（平常是分配新对象导致第0代满）
	2. 什么时候GC1代和2代对象？
	3. 使用代际提升为什么会加速（主要针对老对象）
7. 自动调整每一代预算是怎样做的？什么时候会增加，什么时候会减少？（457）
8. 什么时候会进行GC？
	1. 0代满了
	2. 手动调用
	3. Windows低内存
	4. AppDomain卸载
	5. 程序结束
9. 大对象的回收机制（https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap，459）
	1. 大对象分配在大对象堆（LOH）
	2. 大对象不被移动，所以后来分配的只能利用大对象间的零碎空间或者开辟
	3. 大对象逻辑上从属于第2代，也就是只在第二代进行GC
10. GC的服务器模式和工作站模式的差别是什么（服务器模式将托管堆分块，每个分块被一个CPU负责，回收的时候所有CPU并行进行回收）
11. GC的并发子模式和非并发子模式区别是什么？（开启额外的后台线程在运行时标记对象，如果需要收集第2代时本次GC不回收，就只扩展0代的容量，然后程序继续运行并且并行标记，标记完成后需要回收再挂起回收。但是一般不会回收，所以占用内存更大一些）
12. 强制GC的一些mode
13. 监视应用程序的内存使用的两个方法（GetTotalMemory、CollectionCount）
14. SafeHandle继承自的CreaticalFinalizerObject有什么特点？
	1. 一旦构造该类型对象时Finalize方法一定会被JIT编译
	2. 该类型及派生类型对象会在一般对象之后被Finalized。
	3. AppDomain被强行中断也会调用Finalize
14. 定义了IDisposable接口之后，类中的所有方法都要实现一旦资源被显式清理之后，抛出System.ObjectDisposedException，这样可以给用户以合理的提示。而Dispose方法重复调用则直接返回。
15. using在定义了IDisposable对象使用时的逻辑是什么？（创建一个对象并自动为该对象生成try...finally块，并在finally块中执行Dispose()，474）
16. 应对实际分配的本机资源占用内存的情况比对象大的方法：
	1. GC.AddMemoryPresure（将实际内存占用添加进GC的计算之中）
	2. HandleCollector对象，用于对数量进行管控（实际上这玩意就是个计数，调用Add和Remove方法使计数上下徘徊，如果超过了设定的Threahold之后就会GC）
17. Finalize调用逻辑：
	1. 对象被判断为垃圾，进入终结列表。
	2. 终结列表的对象被扫描，有Finalize()的被扔到FReachable列表，对象复活。
	3. 好了现在有根引用他们了，他们不是垃圾，所以被提升。
	4. 一个特殊的线程在这之后调用这些Freachable对象的Finalize，并同时从f列表中移除之。
	5. 下一次清理老一级代数的时候，这些freachable对象没根了，被清理。（注意这之间可能有很多次清理本代的GC）
18. GCHandle的用法，几个mode都是什么：两个监视（是否finalize，），两个控制（是否Pinned）。
	1. GCHandle的Normal是什么情况下对象依然存活？
19. ConditionalWeakTable的特点如何？key和value的生存期？（ConditionalWeakTable不能保证key存活）
20. Dispose的作用？（允许使用者控制类所包装的本地资源的生存期，471），Dispose之后对象还能否访问？（可以，只不过包装的本地资源被释放了，472）
21. 458页代码能够会解释，会用。
	这个代码要实现一个事：当CLR对0代和2代进行GC的时候调用用户的回调。
	方式是利用对象的Finalizer，因为当Finalizer调用的时候意味着刚刚完毕了一次回收。于是实际需要创建两个对象，一个监控第0代一个监控第2代。
	而这两个对象需要一直存活在0和2代。2代的那个很好满足，GC.ReRegisterForFinalize()让GC反复“再调用一次我的Finalizer”从而不停停留在Freachable列表中；0代的是个问题，因为如果用前述函数它会被提升到1代、2代从而没法维持监控0代的逻辑，于是任Finalize杀之，同时重新new一个新的对象。
	两个对象作为内嵌类放在静态类里面就包装了一个GCNotification。
	其中有一些较为零碎的点：
	1. 嵌套类本身可以实例化为监控器，并且可以直接访问外部类的回调。结构比较精简。
	2. Volatile.Read()满足了可见性（必须从RAM中读取）、有序性（后面语句的读写不会因为优化跑到前面），引用类型的读写具备原子性，一起实现了委托的线程安全读写。
	3. 调用委托前，check是否为null
	4. 卸载进程（CLR关闭）和AppDomain等的时候都会GC，此时就别复活了。
22. 为什么458代码片段中委托要被赋值给temp并且这个赋值理论可行？（因为委托是immutable的，所以添加委托真的就跟Combine那一部分讲的一样，就是生成新的对象并返回）
23. 

## 24. 序列化
1. 序列化的原理是什么（序列化时分析元数据，反序列化时加载程序集。依据元数据序列化对象）
2. 枚举和委托类型总是可序列化的
3. OnDeserialized的调用顺序。
4. OptionalFieldAttribute的用处。
5. FormatterServices的序列化机制：
	1. MemberInfo（GetSerialisableMember）数组和Object[]数组（GetObjectData）->写入程序集标识+类型完整名称->写入两个数组
	2. 根据流中的数据集和type寻找程序集并构造类型->构造未初始化对象（分配内存）->从程序集构造MemberInfo数组->根据MemberInfo数组初始化Object数组->用新分配对象，MemberInfo数组和Object数组构造对象。
6. Iserializable解决了什么问题？机制是什么？是否要求类型具有SerializableIntribute？
7. 序列化代理解决了什么问题？如何使用？







## 段瑞问题
接口和抽象类的区别
静态类在被编译成元数据的时候会定义成什么样的一个类：不能实例化，不能派生(sealed   abstract)
为什么会装箱
GC的工作原理：并发，非并发，服务器，客户端
常量和静态字段的区别：从限制和初始化方向去想
泛型约束，约束的几种类型以及它们的区别

P553代码解释，做一个例子出来
目的是绕过全能但低效的反射机制，将哈希表中的数据进行序列化和反序列化；另外反序列化后的哈希表内部对象可能会改变，所以需要重新计算哈希值等，这部分需要手动控制。
序列化需要实现ISerializable的GetObjectData(SerializationInfo, StreamingContext)方法，即根据StreamingContext，将需要序列化的值以{"名称":"值"}的方式写入CLR根据类型构建的SerializationInfo内部的表中以备反序列化。
反序列化首先需要一个特殊的以先前SerializationInfo和StreamingContext作为输入的构造器用于构造对象（逻辑与先前想死）；但是调用该构造器时并不能保证每一个字段引用的对象都已经完全反序列化——然而调用Insert对哈希值进行重建时可能需要保证所有item的字段都设置完毕，所以这里还需要一个OnDeserialized特性方法或者对IDeserializationCallback的实现，在这些函数之中进行实际的Dictionary的重建工作可以保证所有字段引用的对象的字段都已经重建完毕。
另外，由于实际工作在OnDeserialization中进行，所以在反序列化特殊构造函数和OnDeserialization之间需要一个字段临时存储一下SerlizationInfo作为桥梁。
至于安全性设定这一块可能还需要再理解一下。

### 异常处理的问题
2021年 1月 6日 星期三 17时14分48秒 CST
1. finally catch块在什么时机去调用的。
2. 反射过程中抛出什么异常，线程中抛出异常线程中是怎么捕获这个异常。
3. 怎么看待从例程中抛出。。。什么结构化的视角
4. lock？ using foreach这些语块的异常捕捉行为
3. Winodws的结构化处理。 

## 服务器方向
1. 计算机网络（几层协议，我们是在哪一层上面运作的，TCP/UDP要熟悉，TCP的状态图，然后Windows Socket编程）
2. 多线程(就是c#这边的工具)
3. 20号开始服务器答疑，《CLR》后面章节以及《windows多线程编程》。

## 客户端方向
1. 三月开始，Unity文档和教程。应该是李大佬带，怕了怕了。

## 图形方向
1. 咨询蒋睿
一开始可能跟客户端方向相仿，做一些简单的渲染，基于DX11等等。然后就是简单的shader。

## 我的考虑
1. 选择客户端方向：
	优势：
	1. 比较靠近游戏，有意思。
	劣势：
	1. 顶层工具变化较快。
	2. 转行不易。
2. 选择服务器方向（）：
	优势：
	1. 靠近技术，如果比较底层，可以满足求知欲。
	2. 用到的技术应该可以在转行的时候提供一定好处。
	劣势：
	1. 可能比较无趣。
3. 选择技术美术方向：
	优势：
	1. 听起来太几把有意思了！
	劣势：
	1. 国内好像需求不高。
	2. 好像要求比较坚实的数学功底。

