

## 2. 栈，队列和链表
1. 队列为什么需要将尾指针至于最后一个位置的下一位？
	估计是因为空列表和1单位列表没办法区分。
2. 链表的头指针为什么是空？
	估计也是因为空链表的问题
3. 用链表去实现栈和用数组去实现栈的差别，在什么情况下谁更合适？
	因为栈其实也不需要排序什么的，下标对于栈本身意义也不大。做查询也基本都是遍历查询，可能只有和别的数据结构结合的时候下标才更有效一些。
	所以链表就效率上而言倒也ok。
	为什么有这个问题：因为小猫钓鱼这个题，他用了数组实现的，具备位置->牌号的正查，然后维护了另一个数组做了牌号->位置的反查。这样check是否存在一致的牌的时候就很机敏。
	但实际上这里是有违了栈这个东西的简洁和封闭，因为按说我们是不知道栈的实现细节的，我们只应当期待有一个带有push和pop的单头进出的玩意。
## 3. 枚举，很暴力

## 4. 万能的搜索
1. 递归共享状态暂时有两种方法：
	1. 使用对递归而言的全局ref变量并向下传递，直接修改，全员透明
	2. 使用返回值，更新caller的局部变量。
	3. 如果是全联通图，既然叫图的遍历，那么广度优先和深度优先都会一次性遍历到每个点，如果给每个遍历到的点都做标记并不再遍历，那么他们应该是一样的速度。
		1. 非全联通图，找最近路径的话深度优先可能会重复展开某些点，广度优先倒是不会，但是它会把起点周围的点一点一点剥开去搜索。
		2. 全联通的一种特殊情况深度优先效率很低，就是可通行区域是方形，中间是target，深度优先在第一次遍历的时候会找到最远路径，然后就是冗长的"返回->重新找"的过程，广度优先就还好。这样说来似乎联通度较大的时候使用广度优先，而联通度较小的时候使用深度优先？也不是啊，一条路的极端情况深度优先和广度优先效果一致。

## 5. 最短路径
1. Dijkstra和A*实际上就差一个估计值，但估计值不仅用于对open优先队列进行排序，实际上还间接用于了close队列的最终确认。
2. Dijkstra的“松弛”是指的什么
3. Bellman-Ford的机制是什么

## 6. 树
1. 树的index/2关系只能在index是从1开始的时候才成立
2. 。
