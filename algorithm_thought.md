

## 2. 栈，队列和链表
1. 队列为什么需要将尾指针至于最后一个位置的下一位？
	估计是因为空列表和1单位列表没办法区分。
2. 链表的头指针为什么是空？
	估计也是因为空链表的问题
3. 用链表去实现栈和用数组去实现栈的差别，在什么情况下谁更合适？
	因为栈其实也不需要排序什么的，下标对于栈本身意义也不大。做查询也基本都是遍历查询，可能只有和别的数据结构结合的时候下标才更有效一些。
	所以链表就效率上而言倒也ok。
	为什么有这个问题：因为小猫钓鱼这个题，他用了数组实现的，具备位置->牌号的正查，然后维护了另一个数组做了牌号->位置的反查。这样check是否存在一致的牌的时候就很机敏。
	但实际上这里是有违了栈这个东西的简洁和封闭，因为按说我们是不知道栈的实现细节的，我们只应当期待有一个带有push和pop的单头进出的玩意。
## 3. 枚举，很暴力

## 4. 万能的搜索
1. 递归共享状态暂时有两种方法：
	1. 使用对递归而言的全局ref变量并向下传递，直接修改，全员透明
	2. 使用返回值，更新caller的局部变量。
	3. 如果是全联通图，既然叫图的遍历，那么广度优先和深度优先都会一次性遍历到每个点，如果给每个遍历到的点都做标记并不再遍历，那么他们应该是一样的速度。
		1. 非全联通图，找最近路径的话深度优先可能会重复展开某些点，广度优先倒是不会，但是它会把起点周围的点一点一点剥开去搜索。
		2. 全联通的一种特殊情况深度优先效率很低，就是可通行区域是方形，中间是target，深度优先在第一次遍历的时候会找到最远路径，然后就是冗长的"返回->重新找"的过程，广度优先就还好。这样说来似乎联通度较大的时候使用广度优先，而联通度较小的时候使用深度优先？也不是啊，一条路的极端情况深度优先和广度优先效果一致。
2. 为什么扑克牌全排列和最短路径都是深度优先？
   1. 全排列&最短路径都可以用图表示
      1. 全排列->每拿到一张牌，下一步可以继续拿所有没有拿到的牌->全连接图
      2. 最短路径->每走到一个点，下一步可以继续展开所有相邻的点->无向全连接图
   2. 差异：
      1. 全排列->需要输出所有路径
      2. 最短路径->需要输出最短路径
      3. 实际上就是两者的end condition不同
3. 使用递归求解需要回溯的问题的时候都需要一个操作，即在递归函数调用完毕后需要将当前状态设定为未占用状态（不可重入的问题）
   1. 此外需要定义End Condition
   2. 使用队列求解也一样，问题不在于方法，而在于节点不可重入，没有进入自己的回路
### 图的表示
#### 邻接矩阵
1. 

#### 邻接表
1. 

## 5. 最短路径
### Floyd-Warshall算法
1. 其实很简单，算法的核心就是A到C，如果中间经过B，那么A到C的距离会不会变短，如果会，在一开始的邻接表上记录这个距离，并备后面使用。只需要在一个表上修修改改就行了
2. 不会出现前面的距离数据没有后面更新过后的距离数据好的情况？
   1. 注意每次更新最外层循环的时候意思实际是：在经过**不大于k角标**的所有点的情况下，是不是有更短的路径
   2. 落实到代码上，注意每次循环，所有的点对的距离都完全重新算了一遍
### Dijkstra算法（单源最短路径）
1. 学会了，迪科斯彻就是带距离排序的宽度优先搜索，唯一的差别就是展开点的时候使用的是距原点最短距离的点
2. 邻接表的数组实现中，左边是u、v、w数组，右边分为两个数组：
   1. 第一个部分是所有顶点的边的"头节点"：长度为n
   2. 第二个部分是所有边的“下一条边”，也就是链表的下一个部分

3. Dijkstra和A*实际上就差一个估计值，但估计值不仅用于对open优先队列进行排序，实际上还间接用于了close队列的最终确认。
4. 为什么Dijkstra算法在选中节点后根据这一节点的所有出边更新距离的步骤我非常模糊呢？
   1. 因为其他的遍历算法的典型题目并没有更新距离的设定，只是“有没有路”而不是“最短路”。但是如果更新距离其实也可以，毕竟DFS和BFS都可以遍历所有的路，加一个`dis[]`实际上是轻而易举的事情
5. Dijkstra的“松弛”是指的什么

### Bellman-Ford算法（没看透）
6. Bellman-Ford的机制是什么
7. 外循环是定点数-1，内循环是边数
   1. 内循环好理解，就是经过所有给出的边（重要：边的给出格式是u、v、w），看看是否dis[v]可以被dis[u]+w变小，如果可以就更新
   2. 外循环是“最多可以经过几条边”，n个顶点的图任意两点间的最短路径最多包含n-1个边就行了

## 6. 树
1. 树的index/2关系只能在index是从1开始的时候才成立
2. 任何两个顶点有且仅有唯一一条通路
### 最小生成树
1. 生成树：在图论中，*无向图*$G$的生成树是具有$G$的全部顶点，但*边数最少*的连通子图
2. 最小生成树：*连通加权无向图*中*权值最小*的生成树
   1. 无权图没有意义，因为无权图的所有生成树边数和都相同
#### Prim生成树算法
1. 和Dijkstra一致，都是根据新加入的点更新到各个顶点的最近距离
   1. 但这里距离指的是到生成树（树里面的所有点）的最近距离
      1. 所以并不用把到“起点”的距离加上，只是更新为当前展开点的距离即可
2. 

