

## 排序
### 快速排序
1. 思路：随便选一个数，使用这个数将其他数划分成比他小的和比他大的分别在这个数两边，然后递归排序两边的数
2. 快速改进：两侧使用哨兵，右边先走，如果左边大于右边交换，最后碰上了就交换基准数和碰撞书

## 2. 栈，队列和链表
1. 队列为什么需要将尾指针至于最后一个位置的下一位？
	估计是因为空列表和1单位列表没办法区分。
2. 链表的头指针为什么是空？
	估计也是因为空链表的问题
3. 用链表去实现栈和用数组去实现栈的差别，在什么情况下谁更合适？
	因为栈其实也不需要排序什么的，下标对于栈本身意义也不大。做查询也基本都是遍历查询，可能只有和别的数据结构结合的时候下标才更有效一些。
	所以链表就效率上而言倒也ok。
	为什么有这个问题：因为小猫钓鱼这个题，他用了数组实现的，具备位置->牌号的正查，然后维护了另一个数组做了牌号->位置的反查。这样check是否存在一致的牌的时候就很机敏。
	但实际上这里是有违了栈这个东西的简洁和封闭，因为按说我们是不知道栈的实现细节的，我们只应当期待有一个带有push和pop的单头进出的玩意。
## 3. 枚举，很暴力

## 4. 万能的搜索
1. 递归共享状态暂时有两种方法：
	1. 使用对递归而言的全局ref变量并向下传递，直接修改，全员透明
	2. 使用返回值，更新caller的局部变量。
	3. 如果是全联通图，既然叫图的遍历，那么广度优先和深度优先都会一次性遍历到每个点，如果给每个遍历到的点都做标记并不再遍历，那么他们应该是一样的速度。
		1. 非全联通图，找最近路径的话深度优先可能会重复展开某些点，广度优先倒是不会，但是它会把起点周围的点一点一点剥开去搜索。
		2. 全联通的一种特殊情况深度优先效率很低，就是可通行区域是方形，中间是target，深度优先在第一次遍历的时候会找到最远路径，然后就是冗长的"返回->重新找"的过程，广度优先就还好。这样说来似乎联通度较大的时候使用广度优先，而联通度较小的时候使用深度优先？也不是啊，一条路的极端情况深度优先和广度优先效果一致。
2. 为什么扑克牌全排列和最短路径都是深度优先？
   1. 全排列&最短路径都可以用图表示
      1. 全排列->每拿到一张牌，下一步可以继续拿所有没有拿到的牌->全连接图
      2. 最短路径->每走到一个点，下一步可以继续展开所有相邻的点->无向全连接图
   2. 差异：
      1. 全排列->需要输出所有路径
      2. 最短路径->需要输出最短路径
      3. 实际上就是两者的end condition不同
3. 使用递归求解需要回溯的问题的时候都需要一个操作，即在递归函数调用完毕后需要将当前状态设定为未占用状态（不可重入的问题）
   1. 此外需要定义End Condition
   2. 使用队列求解也一样，问题不在于方法，而在于节点不可重入，没有进入自己的回路
### 图的表示
#### 邻接矩阵
1. 

#### 邻接表
1. 

## 5. 最短路径
### Floyd-Warshall算法
1. 其实很简单，算法的核心就是A到C，如果中间经过B，那么A到C的距离会不会变短，如果会，在一开始的邻接表上记录这个距离，并备后面使用。只需要在一个表上修修改改就行了
2. 不会出现前面的距离数据没有后面更新过后的距离数据好的情况？
   1. 注意每次更新最外层循环的时候意思实际是：在经过**不大于k角标**的所有点的情况下，是不是有更短的路径
   2. 落实到代码上，注意每次循环，所有的点对的距离都完全重新算了一遍
### Dijkstra算法（单源最短路径）
1. 学会了，迪科斯彻就是带距离排序的宽度优先搜索，唯一的差别就是展开点的时候使用的是距原点最短距离的点
2. 邻接表的数组实现中，左边是u、v、w数组，右边分为两个数组：
   1. 第一个部分是所有顶点的边的"头节点"：长度为n
   2. 第二个部分是所有边的“下一条边”，也就是链表的下一个部分

3. Dijkstra和A*实际上就差一个估计值，但估计值不仅用于对open优先队列进行排序，实际上还间接用于了close队列的最终确认。
4. 为什么Dijkstra算法在选中节点后根据这一节点的所有出边更新距离的步骤我非常模糊呢？
   1. 因为其他的遍历算法的典型题目并没有更新距离的设定，只是“有没有路”而不是“最短路”。但是如果更新距离其实也可以，毕竟DFS和BFS都可以遍历所有的路，加一个`dis[]`实际上是轻而易举的事情
5. Dijkstra的“松弛”是指的什么

### Bellman-Ford算法（没看透）
6. Bellman-Ford的机制是什么
7. 外循环是定点数-1，内循环是边数
   1. 内循环好理解，就是经过所有给出的边（重要：边的给出格式是u、v、w），看看是否dis[v]可以被dis[u]+w变小，如果可以就更新
   2. 外循环是“最多可以经过几条边”，n个顶点的图任意两点间的最短路径最多包含n-1个边就行了

## 6. 树
1. 树的index/2关系只能在index是从1开始的时候才成立
2. 任何两个顶点有且仅有唯一一条通路
### 最小生成树
1. 生成树：在图论中，*无向图*$G$的生成树是具有$G$的全部顶点，但*边数最少*的连通子图
2. 最小生成树：*连通加权无向图*中*权值最小*的生成树
   1. 无权图没有意义，因为无权图的所有生成树边数和都相同
#### Prim生成树算法
1. 和Dijkstra一致，都是根据新加入的点更新到各个顶点的最近距离
   1. 但这里距离指的是到生成树（树里面的所有点）的最近距离
      1. 所以并不用把到“起点”的距离加上，只是更新为当前展开点的距离即可

### 堆
1. 堆的操作一共有如下三种：
   1. 增
      1. 将插入的节点放到堆的最后一个位置，并且**向上调整**（向上调整交换目标只有一个，简单比较一次即可）
   2. 删
      1. 将最顶端节点删除并填充该空节点即可->用什么填充呢？
      2. 用最后一个节点填充好了，不会在中间产生空谷->交换最后一个节点和根节点，然后呢？
      3. **向下调整**（交换目标有两个，分别比较待交换节点和其他节点）
   3. 建立
      1. 将所有的点直接填充，然后从最低最少节点的树开始，依次向上加入新的根节点的方式来进一步将更大的树调整为最小堆（虽然是向上扩展，但是不符合规则的其实是最上面的根节点，根节点需要向下调整）
2. 所以提取出来的基本操作：
   1. `ShiftUp()`
   2. `ShiftDown()`
   3. `Create()`
   4. `DeleteMax()`
   有这些基本操作差不多就结了
3. 队列是队列，优先队列是最小/大堆

### 并查集
1. 也是图算法，用于处理一些不相交不交集的合并及查询问题，应用类似于“在人际关系图中确定连通分量数（不相交集合的数量）”类似的例子。
2. 就是当新的条目表示两个对象有联通的时候，则会在两个对象所处的子树合并，而合并后的树的父节点往往由其中一个对象子树的父节点担任，这个父节点即是这个集合的标识。
3. 书中具体树的表示是数组表示，数组的下标是元素的index，而内容则是父节点的index。
   1. 和堆不同，堆的数组下标是结构参数（父节点index=当前index/2），值是实际内容；而并查集的下标可以算作是内容，而值则是结构参数（父节点index），所以会有点迷惑

# Game Programming Algorithms and Tachtiques: A Platform-Agnostic Approach
## Physics 
### 八叉树
1. 常常用来加速几何体间的相交判定
2. 特性：如果形状$S$与节点的空间$A$不相交，那么$S$与$A$下的所有物体都不相交

## AI
### 寻路
#### NavMesh
1. Navigation Mesh使用凸多边形划分的原因是凸多边形边上的点都可以相互连接连成的线也在多边形内部
2. 烘焙过程：
   1. 根据agent的形状（就是Unity中的那个NavAgent定义界面）和障碍物的形状求出expanded障碍物，并将他们合并并根据平面法线（是否可以攀登）求出场景的configuration space（也就是玩家的中心可以抵达的区域）
   2. 这些区域现在是一整片或者多个整片，片内可能存在障碍物或者非凸，导致Agent无法越过这些区域，所以此时需要用三角剖分算法一类的手段对这些非凸区域进行剖分将之划分成凸多边形
   3. 有了这些凸多边形，似乎就可以应用寻路算法了

## Networked Games
### Protocols
1. 所谓协议，可以类比为信件，有from、to、邮票、内容，而协议的格式，就可以类比信封，有标准的设计
2. ICMP协议：
   1. 并非用于传递large amounts of data，所以不能用于发送游戏数据
      1. 他的Payload之中就是timestamp
   2. 但是，它具有echo能力，就是可以测试round trip的延时，于是可以用于ping
      1. ping - the process of measuring he latency to a particular address
3. ICMP的request和response是通过header中的Type来区分的

### TCP
1. 特点：
   1. 要建立连接（3次握手）
   2. 需要端口
   3. 要acknowledge每个包
   4. 保证顺序
   5. 自动break up大包为小包
   有这么多特性支持，简单来说就是一个比较复杂的协议

### Server/Client
1. server-authoritative
   1. 指所有的client action都要在服务器上verified才能应用。
      1. 比如你射了一发子弹，不能在你的客户端扣目标的血，而是发送一个fire的request，然后在服务器计算路线最后击中扣血
         1. 规避两种情况：
            1. 你的数据已经out of date了，敌人早就不在那里（但是那样射击的客户端会非常气愤）
            2. 敌方在本地作弊
2. Client prediction（[来源](https://blog.csdn.net/Lunar_lty/article/details/88606168)）
   1. 指客户端需要去对别的玩家位置进行一定的推测，实际上就是外插；或根据两次变化进行内插
   2. 避免以下情况：
      1. 服务器每秒同步四次，敌方玩家就在这1秒之内teleport了四次，这特么让人怎么射中
      2. 我玩家输入了向左移动，游戏发送向左移动的指令到服务器，两百毫秒之后回来了我才移动妈的。
         1. 这种可以用Dead Reckoning来解决，即航位预测算法
   3. 但在Entity移动加速度很大的情况如FPS，玩家移动是非常敏捷的，Dead Reckoning算法就基本没什么大用，没办法预测，预测出的东西在客户端看起来是非常奇怪的，此时使用一个临时的小技俩：
      1. 将所有的更新缓存100-200ms再播放，这样就给了网络一个200ms的允许延迟，客户端在这200ms之内*看起来仍然是流畅*的
         1. 但这显然还有问题，就是我瞄准的敌人位置是200ms之前的位置，放了看起来可以爆头的一枪，但是...
   4. 哈哈这里给出的解决方案就很鸡贼，是倾向于攻击者的。即根据攻击者发送Fire操作时会附带时间戳，根据这个时间戳可以重建出当时整个游戏状态（重要的是，攻击者眼中的那个客户端的状态！），如果当时那个敌人在可以被射中的位置，即使受害者本人已经在100ms后躲到了掩体后方，还是会被拉出来在被爆头的那个位置死掉！对受害者不友好，但是对攻击者友好。所以这里需要**权衡**。——该方法名叫延迟补偿(Lag Compensation)算法

### Peer to Peer
1. 常用于RTS，实际实现是基于lockstep：
   1. 150ms-200ms将一方玩家的数据打包发送到另一方玩家，两方玩家分别在各自的local game里进行游戏，就好像在打电脑（不理解）
2. 问题是如果一方玩家延迟了，另一方玩家就需要等待
3. 优势在于数据量少