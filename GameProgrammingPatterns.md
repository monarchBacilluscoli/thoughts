# 游戏编程模式

来自Head First Design Pattern和Game Programming Patterns两本书

## OO的几个阶段
### OO基础
* 抽象
* 封装
* 多态
* 继承
### OO原则
* 封装变化（？）
* 多用组合，少用继承
* 针对接口（或者超类型）编程，不针对实现编程（？），指的就是不对某个确定的类型进行编程，而是对一类对象进行编程
### OO模式
那就是接下来很多的模式了

## Strategy Pattern
### 实例
鸭子基类包含Quack()和Fly()，但有些鸭子不飞也不叫，导致需要覆盖原始行为为空，很不优雅。并且如果有很多，需要覆盖很多为空。
### 可能的解决方案
1. 使用IFlyable和IQuackable接口。
   1. 问题：更难受，如果鸭子基类派生出五六十种鸭子，那要进行五六十次编写
2. 使用Strategy Pattern
### 核心
将行为也封装成为具体的类，比如每一种鸣叫方式都是一个类，这些类实现了接口IQuackable()。
基类组合这些接口作为成员
### 优势
* 所有行为可以灵活组合
* 运行时可变
* 基类只需要组合一个IFlyable接口成员即可
### 我的思考
在编程中，类和对象是可以任意组合的，而成员则不行。所以将任何数据和行为变成对象，就很棒
视某一类对象为一个统一的接口，则调用者也很方便


## Decorator
### 实例
咖啡可能有多种调料，价格各不相同，如果为各种调料的排列组合进行继承，那就会有很多子类，这样是很要命的。
### 可能的解决方案
1.使用字段——是否有某种调料 + Cost()函数中判断并加入该种调料的价格
      1. 可能的问题：某种调料的cost改变之后需要修改基类代码，加入新的调料可能需要修改基类的代码
         1. 当牵连的行为比较少的时候问题不大，但牵连的行为一多，修改冗长的基类可能就会出问题
1. 使用Decorator模式
### 核心
1. 调料作为decorator，和被装饰的类型是一种类型
2. 装饰者将被装饰者作为构造函数的参数吞入并保存，用以扩展被装饰者
### 优势
* 灵活
* 通过核心1，可以保持调用者调用装饰后对象的一致性
* 通过核心2，装饰者可以修改内部变量的逻辑

## Singleton
### 实例

### 核心
1. 本身只要一个静态变量确实可以做，但是单例的静态Public Singleton getter可以在Get的时候才推迟实例化这个或许是资源敏感的实例
### 注意
1. 多线程同时创建需要小心，所以需要特殊的同步逻辑


## Factory
### 实例
如果使用具体的new，我就会持有具体类的引用，持有者会依赖于该具体类的实现。
### 核心
1. 两个基类———Product和Creator
2. 所有的concrete product和creator都是继承了前述的基类，Creator代码层面上处理的都是基类类型
### 优势
1. Creator处理逻辑一致（针对接口编程——只有一个地方会出现创建的逻辑代码）
2. 可通过继承在子类中扩展