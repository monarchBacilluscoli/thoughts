# 操作系统原理

## 2. 
1. 系统调用，异常和中断怎么理解?
	1. 面向外设通过中断和IO进行处理
	2. 面向应用程序就提供了系统调用和异常
	系统调用好说，异常虽然是app产生的，但是是运行时产生的意想不到的事情，所以不得不由操作系统去完成相应的功能。
	中断来源于外设，指的是有些特殊的情况需要操作系统的支持，需要提醒操作系统。举例：
		1. 除以0
		2. 访问不属于自己的内存地址。
		3. 某些操作需要权限提升。
	三者的处理时间也不同：
		* 异常：同步
		* 系统调用：均可
		* 中断：异步
		从产生的情况上来说，由于应用程序不知道什么时候会产生，则是异步的；从返回的情况上来说，如果等待返回则是异步的
2. 中断的产生和处理机制
	1.硬件：中断号
	2.软件：保存当前状态->查找中断处理例程->清除中断标记->恢复保存的状态。
3. 异常的产生和处理机制
	保存现场->处理异常（杀死ps/弥补并重新执行语句）->恢复现场
4. 用户态和内核态
	在程序运行中*CPU处于的特权状态*，内核态可以控制IO等所有权限，但用户态则有局限。
5. 系统调用和一般函数调用的区别？
	两个差异：
	1. CPU的特权级从用户态到内核态。
	2. 从进程栈到内核栈。(这一步要涉及应用程序栈的保存和恢复以及操作系统栈的保存和恢复...天哪这么复杂？)
	所以系统调用会比函数调用开销要更大:
	1. 内核堆栈建立
	2. 参数验证
	3. 内核态结果向用户态地址空间*拷贝*
	4. TLB
6. CPU的主要组成部分：
	1. 运算器
	2. 寄存器
	3. 控制器
	4. 缓存
	5. 存储管理单元(MMU)
7. 逻辑地址生成的过程在编译过程中的体现是怎样的？
	源文件
	-(编译器)->汇编语言.s
	-(汇编器)->符号变成编译单元内部的地址.o
	-(链接器)->多个编译单元结合多个.o程序，处理地址依赖，变成全局地址.exe
	-(载入loader)->将所有地址进行偏移，变成内存中程序
	这个过程不需要操作系统的参与
8. 逻辑地址到物理地址的映射关系是谁搞定的？
	MMU
9. ALU执行指令的时候需要地址->MMU给到地址->总线发送请求->内存返回给CPU。
10. 在前述过程中操作系统做了什么？
	建立逻辑地址和物理地址的关系


## 进程
1. 并发concurrency和并行parallel的区别
	并发还是一个一个运行，但是时间很小，看起来像是一起走；并行真的是同时运行。
2. 进程挂起（suspend）和进程阻塞的差别是什么？
	进程阻塞是进程等待一个事件在这期间不占用CPU时间片的状态。
	而进程挂起指的是进程不占用内存空间，它的映像在硬盘上。分为阻塞挂起和就绪挂起。看来这俩玩意是平级的。
3. 阻塞的进程是怎么被唤醒的？
	等待不同事件的进程被分到不同的事件队列里面，事件发生之后操作系统会唤醒1个或者全部进程。
4. 为什么现在的浏览器使用进程的方式而非线程的方式？
	安全性>性能。如果某个网页有恶意代码或者崩溃后不会影响整个程序的运行；并且当前机器性能相对而言比较充裕可以支持这种操作。
5. 用户线程->内核线程
	N to 1, 1 to 1, N to M
6. 线程实现的三种方式
	用户线程：
		优缺点：
		1. 可以在不支持多线程系统上运行
		1. 任一线程IO操作都会使操作系统阻塞整个进程
		2. 除非用户态线程主动交出CPU使用权，否则其他线程无法运行。（因为用户态线程库没类似于时钟中断的特权）
		3. 执行较慢
	内核线程（Windows）：
		优缺点：
		1. 创建、结束和切换都由系统调用/内核函数进行，开销较大。
		2. 线程不会阻塞进程
		3. 时间片分配给进程
	轻量级线程（Linux）：
		N to M（Solaris）好像Linux是1 to 1
		1. N to M更加复杂而灵活
		2. 1 to 1 更加简单
